#!/usr/bin/env python
"""
Evaluate xacro arguments

"""

import os
import sys
import subprocess
from xml.dom import minidom
try:
    import regex as re
except:
    print("Regex lib not available, please install it to use the extend runScript method\n\n\tsudo pip install regex")
import time

rospack = None

try:
    import rospkg
    rospack = rospkg.RosPack()
except: pass

__regex_runscript = re.compile(r'(runScript(?P<match>\((?:(?&match)|[^()]+)*\)))')
__regex_rtt_args = re.compile(r'(\\w+):=(.+)')
__regex_ros_args = re.compile(r'(\$\( *arg *([^) ]*) *\))')
__regex_ros_find = re.compile(r'(ros.find(?:\(((?R)|[^()]+)*\)))')


def __format_str(str_in):
    #print "formatting ",str_in
    s = str(str_in)
    s = s.replace(" ","")
    
    if (s[0] == '"' and s[-1] == '"') or (s[0] == '(' and s[-1] == ')'):
        s = __format_str(s[1:-1])
    #print "s:",s
    return s

def process_ros_args(input_str,args):
    # Looking for parameters
    str_out = input_str
    it = re.finditer(__regex_ros_args, input_str)
    for i in it:
        complete_arg = i.group(1)
        arg_name = i.group(2)
        str_out = str_out.replace(complete_arg,args[arg_name])
    return str_out
    
def expand_runScript(input_str,args,list_of_opended_files,level=0,level_max=10):

    #output_str = ''
    if not list_of_opended_files:
        output_str = '/* Generated by expand_runScript() at '+str(time.strftime("%Y-%m-%d %H:%M"))+'\n' + input_str
    else:
        output_str = input_str
        
    number_of_files_appened = len(list_of_opended_files)
    
    output_str = process_ros_args(output_str,args)
    run_scripts_lines = re.findall(__regex_runscript,output_str)
    
    for run_script_line in run_scripts_lines:
        try:
            #print "RunScript Line",run_script_line
            #print ""
            string_to_replace = run_script_line[0]
            string_to_interpret = __format_str(run_script_line[1])
            #print "string_to_replace : ",string_to_replace,string_to_interpret
            ros_find_lines = re.findall(__regex_ros_find,string_to_interpret)
            
            if not rospack or not ros_find_lines:
                #Classic path
                #print "i'mm gonna open ",string_to_interpret
                if not string_to_interpret in list_of_opended_files:
                    list_of_opended_files.append(string_to_interpret)
                    with open(string_to_interpret,'r') as f:
                        output_str = output_str.replace(string_to_replace,'\n\n/* Expanding '+string_to_interpret+' */\n\n'+f.read())
            else:
                for ros_find_line in ros_find_lines:
                    #print "ros find",ros_find_line
                    ros_find_complete_line = ros_find_line[0]
                    ros_pkg = __format_str(ros_find_line[1])
                    
    
                    ros_path = rospack.get_path(ros_pkg)
                    #print "string to interpret before : ",string_to_interpret," we should add ",ros_path,"instead of ",ros_find_complete_line
                    string_to_interpret = string_to_interpret.replace(ros_find_complete_line,ros_path)
                    string_to_interpret =  ''.join(string_to_interpret.split('+'))
                    string_to_interpret = string_to_interpret.replace('"','')
                    #print "Complete final path : ",string_to_interpret
                    if os.path.isfile(string_to_interpret):
                        if not string_to_interpret in list_of_opended_files:
                            list_of_opended_files.append(string_to_interpret)
                            with open(string_to_interpret,'r') as f:
                                output_str = output_str.replace(string_to_replace,'\n\n/* Expanding ROS '+string_to_interpret+' */\n\n'+f.read())
        except: pass

    #print "****************************\n",output_str,"************************************"
    if not run_scripts_lines or number_of_files_appened == len(list_of_opended_files) or level >= level_max:
        #print "LEVEL = ",level
        return output_str

    return expand_runScript(output_str,args,list_of_opended_files,level+1)

def format_file_xacro(input_file,args):
    import rospkg
    with open(input_file,"r") as f:
        
        s = '<genscript xmlns:xacro="http://ros.org/wiki/xacro">\n'
        for a in args:
            s = s + '<arg name=\"'+a[:a.find(':=')]+'\" value=\"'+a[a.find(':=')+2:]+'\"/>\n'
        s = s + '<script>\n'
        s = s + f.read()
        s = s + '\n</script>\n</genscript>\n'
    
    intput_filename = os.path.basename(input_file)
    output_xacro_filename = rospkg.get_ros_home() +'/'+ intput_filename+'.xacro'
    
    with open(output_xacro_filename,'w') as f:
        f.write(s)
    
    cmd = "rosrun xacro xacro "+output_xacro_filename+" "+str.join(' ',args)
    proc = subprocess.Popen([cmd], stdout=subprocess.PIPE, shell=True)
    (out, err) = proc.communicate()
    if proc.returncode != 0:
        raise RuntimeError("%r failed, status code %s stdout %r stderr %r" % (
                           cmd, proc.returncode, out, err))
                           
    xmldoc = minidom.parseString(out)
    itemlist = xmldoc.getElementsByTagName('script')
    s_out =  str.join(' ',[i.firstChild.data for i in itemlist])
    return output_xacro_filename,s_out

def create_dict_from_argv(argv):
    d = {}
    for arg in argv:
        a = arg.split(':=')
        d[a[0]] = a[1]
    return d


_input_filename = sys.argv[1]
__args = []

if len(sys.argv) >= 2 :
  __args = sys.argv[2:]

_args = create_dict_from_argv(__args)

with open(_input_filename,'r') as f:
    _expanded_output_str = expand_runScript(f.read(),_args,[])

_expanded_output_filename = _input_filename+'.exp'
with open(_expanded_output_filename,'w') as f:
    f.write(_expanded_output_str)
    print(_expanded_output_filename)
exit()





